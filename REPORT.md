# REPORT ChessGame

This app is essentially a chess game. You can play against a friend with the phone in between the two of you, or you can play against your phone. You can also have your phone play against itself. There are four difficulty settings, which is really how many steps the computer thinks ahead. Each subsequent difficulty also has longer 'think-times', during which the computer calculates the best move.

<img src="doc/highlight.jpeg" width="200" title="game with highlighted moves"/>

## High Level Overview
The app mostly consists of two components: the engine and the graphical user interface. 

The engine consists of:
 
* board and tiles
* moves
* pieces
* players
* an Alliance enum
* a PieceType enum
* a Setup class
* and a Tools class.

The GUI consists of:  

* MainActivity
* GameActivity
* ScoreActivity
* SettingsActivity
* SettingsFragment
* a custom GridView named BoardGridView
* and a custom View named BackGroundView.

Outside these components live the GameController, the ScoreObject and the StaticApplicationContext.  

## Detail
### Board and Tiles
Tiles are objects that hold an x and y coordinate and possibly a piece. There are two types of tiles, governed by an abstract **Tile**. These are **TileEmpty** and **TileOcc**(upied). As the names describe are TileEmpty empty tiles and TileOcc occupied tiles. They hold boolean methods that return true or false depending on whether they are empty or occupied. They also have a **getPiece()** method. Occupied tiles hold a piece so the getPiece() method returns that piece. Empty tiles return null when they are asked for their piece. The abstract Tile class holds a Map<Integer, TileEmpty> that contains all the possible empty tiles. **An empty board**. Now in the **createTile()** method in Tile, we only have to check if the tile we are creating should hold a piece and when it does create an occupied tile and else select the appropriate tile from the Map. This means that we don't have to make a new empty tile every time. I could do the same for occupied tiles, but there are six ways for a tile to be occupied and 68,719,476,736  different board configurations, while there is only one way for a tile to be empty. 

The board is a few lists and collections of tiles and pieces. The first thing that happens is that an instance of the board is created. This is the default board, with all the pieces in their initial position. The board is a singleton, because we want to make sure that there is only one instance of the board at a time. The board gets called a lot by other classes and they all must get the same instance. The **createDefaultBoard()** method first instantiates a **Builder**. This is the class that actually sets the pieces and returns a board. So in createDefaultBoard() I use the builder to add the pieces to a list that the builder makes (named **boardLayout**), set the player to White (White and Black and None are in Alliance) and have builder return the Board. This is where the constructor of the Board class is called. 

The constructor gets the builder as a parameter so it can use the same builder for creating itself. In this constructor a 'member board' is created through the method **createNewBoard()**. The mBoard is a List<> of Tiles. Through a nested for-loop all the coordinates on the board between 0,0 and 7,7 are touched. A tile is created through the earlier mentioned createTile() method in Tile with the coordinates of the 'current' tile and a piece from the boardLayout list. If the createTile() method gets a piece that is null (e.g it wasn't there) the method will return the appropriate TileEmpty with the given coordinates from the list of empty tiles. In the createNewBoard() method in Board, the Tile is then added to the list of tiles. After each for-loop concludes the now finished list is returned to mBoard. **The board is now in existence**.

Still in the constructor we will track the pieces of each player. We want the players know their own possible moves. When we set the pieces in the boardLayout we also gave them an Alliance. This is either White or Black. In the method **trackPieces()**, which gets mBoard and Alliance as parameters, we iterate through every tile in mBoard and check if the tile holds a piece. If it does we get that piece and check its alliance, if it matches the one we have as parameter we put it in a collection of pieces. We choose here a collection instead of a list, because order isn't important. These pieces don't need an index like the pieces in boardLayout, because we don't need to get them by their coordinates. After the for-loop concludes we return the collection. Now that we have the pieces, we can get their legal moves. 

### Pieces
Pieces calculate their own legal moves depending on where they are and where others are. Each piece starts by having a final int array POSSIBLEMOVES. For jumping pieces (Pawn, Knight, King) this array is two-dimensional (move, offsets) and for sliding pieces (Bishop, Queen, Rook) this array is three-dimensional (direction, move, offsets). The pieces iterate over these POSSIBLEMOVES and add to a List<> of Moves. I had the **legalMoves()** method itself return a Collection because these moves don't need to be indexed and it is just fine. If the new coordinates are valid (they are within the dimensions of the board) we get the tile at those coordinates and check if there is a piece on it. If not, go ahead and add a MoveNormal to the list, with the instance of the board and this piece and the destination coordinates. If there is a piece at that tile, then we must determine if that piece is allied to us. If it is, we can't go there and no move is added to the list. If it isn't, it is an enemy piece and can be attacked. Now a MoveAttack is added to the list. After each POSSIBLEMOVE is explored we return the list.

### Moves
In the Board class we track the moves per player. With the **trackMoves()** method, we just iterate over all the player's pieces and add all its legal moves to a list which we will then return. 

There is one abstract class **Move** and many other move classes that extend Move. I think it suffices to say that they all differ slightly in their execution. **MovePawnLeap** for example adds the current piece to the board as an enPassantPiece. **MoveCastle** moves two pieces: the King and a Rook. **MoveNormal** just moves a piece while **MoveAttack** also removes a piece. In the **execute()** method the move creates a new **Board.Builder** and places all pieces (except the moved piece and maybe the attacked piece) in a new boardLayout. Essentially we are making a new instance of Board here. This is no problem with regards to the current board being a singleton. This instance will be replaced later by this new board.

### Players
Now that we have the moves per player, we can create the **PlayerWhite** and the **PlayerBlack**. They have a super abstract **Player** class. The Player class has an **attacksOnTile()** method which returns a Collection of moves that have their destinations at a given tile coordinate. Players should also keep track of their king. Their king is returned to them by the **whoIsMyKing()** method. This is needed in order to determine if a player is in check or not and if their particular king has any moves to get out of check. This is accomplished by using the attacksOnTile() method to determine if any moves have the kings position as destination. Castling moves are also created inside the Player class. This is because castling can't be done when the king is in check, or when the tiles in between the rook and king are attacked. To check for this we need the collection of enemy moves. If we were to create the castling moves inside the **King** class (which seems natural), the enemy moves collection won't be made yet. The Castling moves are then added to the legalMoves of the player using guava library **concat()** method. Now both players have their full legal moves for this board configuration.

### Alliance
Because integer values are not really typesafe (meaning they can be replaced by unrelated integers) I chose an enum: White, Black. A great benefit of this is that we can attach methods to these values. **getDir()** is used to return -1 for White and 1 for Black. This method is called during Pawn creation during its legalMoves() method to set the direction of motion. White pawns move in a descending along the y-axis and black pawns in an ascending manner. So the offset for White must be negative while the offset for black must stay positive. Later we will want to know if a piece is White or Black so the boolean methods **isBlack()** and **isWhite()** return true and false respectively. When we create a new board we must set the current player on that board to the player. During the creation of a board we will get the next player in the current board, get the alliance and call the connected method **chooseNextPlayer()** which will return BLACK if it is connected to WHITE and vice versa. So the player on the new board is in actuality the old player from the old board and is now used to get the previous alliance to get the opposing alliance to get the current player.

### PieceType
The PieceType enum is contains BISHOP, KING, KNIGHT, PAWN, QUEEN, and ROOK. Attached to each of these (of course) is a method to determine if a piece is a King and a method that returns the value of a piece. This value is used later in the computerplayer's board evaluation.

### BoardGridView
This is a custom **GridView**. It is the board the player sees. Since it is a visual component which uses a canvas, it holds a lot of Paint. These are set in the **setPaints()** method. This method extends GridView and as such has to override some methods. **onSizeChanged()** is a nice method for example to call **calculateDimensions()** in. This sets the dimensions of the boardTiles relative to the screen. In the **onMeasure()** I force the view to be square by limiting the size of each axis to the shortest side. At first I had almost the entire class in the **onDraw()** method, but **betterCodeHub** advised me to break up that method into smaller pieces.
First, we draw the board in the **drawBoard()** method. With a nested for-loop we iterate over every potential tile. Only the dark tiles are actually drawn, the white tiles are just background. if a row's number is uneven but the columns number  isn't (and vice versa) a dark tile is created. So on uneven rows the even columns get a dark tile, and on even rows the uneven columns get a dark tile. Then four lines are drawn around the board to create a border.
Second, we draw the pieces. In the **drawPieces()** method we once again iterate over the tiles' coordinates and give those coordinates to **createBitmap()**. This method gets an instance of the board, uses its getTile() method the get the tile at these coordinates and then the obtained tile's getPiece() method the get the occupying piece. I had earlier overridden the toString() method of the pieces to test my board before the GUI was finished. This came in handy because the toString() method for the pieces now returned single letters indicating what pieceType it was. So if this piece actually exists the createBitmap() method will make a key which might look like this: QB. This stands for Queen Black and QB corresponds to a resource id for a picture of a black queen in a resource map made by **resourceMapMaker()**. The createBitMap() method then returns a bitmap of that resource to drawPieces() and the latter then draws it. I did something similar in the second preset of Native App Studio "MadLibs" where I wanted a random story and just renamed them to madlibs1, madlibs2, etc. and then just had a random number between 1 and 5 added to the resource id which was just 'madlibs'.
Third, various highlights are drawn in their respective methods if their conditions are met. They are just rectangles and circles of different paints.
Fourth, the endState is drawn if a player forfeits or is checkmated or is stalemated. A black or white field which is slightly transparent is drawn over the field and an appropriate message is displayed (also drawn).

In the onTouchEvent we handle the touch of a place in the grid. This returns an x and y coordinate which is then used to retrieve the right tile (startTile) from the board in the engine and subsequently the piece (selectedPiece) that might be on it. A second touch checks if there is already a piece gotten and if so a destinationTile is retrieved from the board. If this is not the same tile as the startTile then we can use the MoveMaker class to retrieve the move that has these start- and destination-coordinates. The **AlternateBoard** class, holds a board and a 'flag' for that board called MoveWas, indicating whether the move was LEGAL or ILLEGAL. At this point we have the player execute with the **makeMove()** method the move and check if it is a legal move or an illegal one. The Player then returns an AlternateBoard that is flagged either LEGAL or ILLEGAL or LEAVESKINGINCHECK. That last one what for debugging purposes. When a move is not LEGAL, the AlternateBoard contains the same board as which already exists. Only LEGAL flagged AlternateBoards hold new boards with the pieces moved. In the onTouchEvent().doMove() method if the AlternateBoard is flagged LEGAL, then the current instance of the Board is set to the new board that it holds. *The AI is notified of the move*.

### BackGroundView
The BackGroundView is a custom View which is located behind the BoardGridView. This allows me to draw on either side of the board. Here informative markers are drawn to indicate the current player and the state of the player: Normal, Check, and CheckMate. The getBitmapFromVectorDrawable() method I copied straight from <a href="https://stackoverflow.com/questions/33696488/getting-bitmap-from-vector-drawable">here</a> on stackoverflow. I chose vector drawables here because they seem less pixelated.

### Setup
The Setup class sets the Type of the players. This can be either HUMAN, or COMPUTER. There is also a method for checking if a player is a computer. Also the depth at which the computer calculates the best move is defined here. This information comes from sharedPreferences where the user has saved their settings through the SettingsFragment.

### Tools
Tools contains the static board dimensions, a static **isValid()** method, and a static **convertPosition()** method. This last one is used every time two coordinates must be converted to one index or tile number.

### MainActivity
This activity is the first one you see. It contains an Play button, a Score button and a Settings button.
The StaticApplicationContext is set here, to make sure it is available when the game starts or the settings menu is accessed.

### GameActivity
This is the chess game, or the initialiser anyway. If this activity is finished() but the instances of Board and GameController still exist then the game will continue in the background. That is why I have overridden the onBackPressed() method to show an alertDialog when the player attempts to leave a Computer vs Computer game (the only game where moves are made continuously in the background) in order to notify them that if they continue the instances of Board and GameController are set to null. 

In the onCreate() method an instance of the board is retrieved or created. THEN the contentView is set. BoardGridView has calls to an instance of the board, so the board must exist first. Then references to BoardGridView and BackGroundView are retrieved. These are then passed to an instance getter for GameController. The references to these Views are static in GameController so they can be invalidated throughout the whole engine now.

Among the content for this view are two buttons. Reset and Forfeit. Reset calls for a new default board and Forfeit sets the current player's status Forfeited to true.

### ScoreActivity and ScoreObject
The ScoreActivity just displays the current score of White and Black. These scores are on startup retrieved from SharedPreferences and stored in the ScoreObject. The Board when endGame() is called also adds one point per board to either player when CheckMate is achieved or one player has forfeited.

### SettingsActivity and SettingsFragment
Here I followed the official android documentation on how to make a SettingsActivity. It has a fragment that contains three CheckBoxPreferences that through if statements are manipulated to act as RadioButtons and a ListPreference that shows lists the difficulties. Changes are saved in SharedPreferences.

### GameController
The GameController is a singleton and an Observable. It it tracks the current player and notifies its observers of any changes. It contains a sub-class called TurnWatcher which is an Observer. When it is notified of a change it may create an AsyncTask called Thinker depending on whether the current player is a COMPUTER or not. Thinker then creates an instance of the AI algorithm in the background, to keep the app responsive and onPostExecute() executes the resulting bestMove and notifies itself through GameController if the next current player is also a COMPUTER.

### MiniMax
MiniMax is an algorithm that aims to minimize the maximum gains for the other player. <a href="https://en.wikipedia.org/wiki/Minimax">Here</a> is a wikipedia article on the subject. It essentially creates a trie until a given depth, by co-recursive calling of the min() and max() methods. These are identical, but min() tracks the lowest scoring board and max() tracks the highest scoring board. The trie consists of all possible boards originating from every possible move that executed. This means exponential growth as every resulting board has moves that create new boards. This is why I have limited the search depth in Settings to 4, because 5 would take 30 hours per move. When the depth is reached, the instances of both methods start evaluating the boards from the bottom up, propagating the desired outcome upwards. When all conclude a bestMove is chosen and returned to Thinker. Boards can have both positive as negative scores. Positive scores mean White has an advantage, and negative scores mean Black has an advantage. 
Boards are scores by an Evaluator. Here a score is given to the board by giving the White and Black player each points for thinks like total piece value, or the amount of moves a player can make. Black's points are then substracted from White's points, resulting in a positive score if white has more points and in a negative score if black has more points. This score is then returned to the currentScore in the calling method(). I can add things to this evaluator to make the AI behave differently, such as granting points to checking the opponent's King. 

## Challenges
Originally I wanted to have a GridLayout filled with TileViews which may or may not contain an image of a piece. I couldn't get it to work and I was impatient, so I changed my mind and I started to make a custom GridView and just draw the tiles on. The drawn on tiles looked great and the onTouchEvent() was returning the right coordinates on the right tiles. However, when I tried to draw on the pieces (I tried to make an adapter for the GridView, and the pieces where vector images) they where drawn all wrong. This was around the time I made the DESIGN.md and the engine wasn't even started yet. So I gave the GridLayout with TileViews another shot, but quickly gave up. I started work on the engine and when the pieces actually existed I looked back at my GUI. Then I realised I could draw Bitmaps on a canvas, so now I needed Bitmap objects of the drawables. I couldn't easily figure out how to make a Bitmap of a vector image, so I exchanged them with png's. They looked precisely right the first time. In an ideal world I would have stuck with the GridLayout and TileViews, because I think these would scale better on different screen sizes. Also they would be easier to connect to their Tile counterparts in the engine. Possibly.

I needed the instance of the board in BoardGridView, but I was hesitant to make it a singleton again. I thought that since I was going to make new boards out of moves I shouldn't make a board a singleton. It wasn't my original design, but I decided that I would just try it and it turned out for the best.

I needed to invalidate the BoardGridView when the computer had mad its move. But I couldn't invalidate it without reference and I couldn't make a new BoardGridView, because it would be different than the one I was trying to invalidate. I read on different pages on stackoverflow that I should pass the reference to where ever I would need the reference and that sounded pretty sane, so I did it and it worked.

I had some problems with the SettingsActivity/Fragment and the Setup class, where I set the type of player and the search depth of the computer. I didn't realise that all the variables in the xml file preferences where saved as strings, while I was trying to get integers from them. It took way too long and was eventually fixed easily. 

There where some problems with saving the scores to sharedPreferences, but it turned out I was just doing it wrong. I tried to save the score to preferences with activity context, but this would be a different preferences in another activity. I stupidly tried to get the values from sharedPrefences anyway, even though I hadn't saved it to there. I also tried to put integers into a TextView... Converted them to String and it worked.

I had tremendous trouble with just little mistakes here and there that prevented the code from working properly. Like the enPassantPiece, a variable that is initialised in the Board constructor. It is used during the legalMoves() method of the Pawn. Yet I initialised it after all the moves where already made. The pawn saw that the variable was null, and didn't put a MoveEnPassant in legalMoves, it didn't work. I couldn't see why and was on the verge of removing the feature all together, but then I explained to someone how it should work and I realised my mistake. So too had I only updated the references for the BoardGridView and BackGroundView in GameController when there was no instance of GameController, meaning that when I exited GameActivity and re-entered it, it would try to get a GameController that still had the old references, but not update them to the new ones. This resulted in the Views no longer refreshing. Almost took me a week to figure that out.

At first I thought it would be nice to retain the current game when the app was not in use, but still running in the backGround, but during a Computer vs Computer game I couldn't suspend the process of notifying and creating AsyncTasks, so I chose to display an AlertDialog when such a game was happening and set the instances of GameController and Board to null and finish the GameActivity when the user backpressed. 

For connecting the AI I had to have an Observable object that wasn't changing instance, wasn't already extending some other class, and is handy. So Board wasn't a great candidate, because it was always changing and BoardGridView already extended GridView. I decided to make a whole new class that was a singleton and while I was at it stick the only observer in there as well and call it GameController. If I had the time I would have explored other options, but I don't think creating GameController was a mistake. If I had made Board observable, that would have added calls to Board, so it would have been better to separate concerns and make a separate class. 

If I had the time I would add more functions such as a move counter and a move log that display feats like checkmating someone in the least possible moves and maybe use the move log to replay a chess game.
